<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Arithmetia</title>
  
  <!-- HTML -->
  

  <!-- Custom Styles -->
  <!--link rel="stylesheet" href="style.css"-->
  <style>
    body {
    background-color: #12131A;
}
#container {
  width: 328px ;
  height: 403px;
  margin: auto;
  border: 5px solid white;
  background-color: green;*/
  background-image: url("Images/grass.jpeg");
  position: relative;
  /*clip-path: circle(50%);
  /*-webkit-mask-clip: circle(50%);*/
}
#divMainPlayer {
  top: 25px;
  left: 150px;
  position: absolute;
  height: 25px;
  width: 25px;
  background-color: #00F;*/
  /*background-image: url("Images/Cola.png");*/
  border-radius: 10px;
  border: 1.5px solid black;*/
}
#controls button {
  margin: 2px;
  height:70px;
  width: 70px ;
  font-size: 60px;
  font-style: bold;
}

body :last-child div {
  height: 25px;
  width: 25px ;
}

  </style>
</head>
<body>

<div id="container">
  
  <div id="divMainPlayer"></div>
</div><br>

<div align="center" id="controls">
  <button align="center" onclick="moveObject(objMainPlayer, 1, -1)">^</button><br>
  <button onclick="moveObject(objMainPlayer, 0, -1)"><</button>
  <button onclick="moveObject(objMainPlayer, 1, 1)">v</button>
  <button onclick="moveObject(objMainPlayer, 0, 1)">></button>
</div> 

<div>
  <button onclick="alertInfo()"><b>?</b></button>
</div>

  <script>
    //Setup
//var playerMapCoords;
var actObject= [/*type, playerMapCoords*/];
//var acting = false;
var movementBoundaries = {
  minXY: [0,0], 
  maxXY: [12,15], 
}
let objMainPlayer = {
  actXY: [6,1], 
  styleXY: [150,25], 
  acting: false, 
  htmlStyleEquiv: divMainPlayer
};
var interval;
var map = [
  [0,0,0,0,0,0,0,0,0,0,0,0,2],
  [0,0,0,0,0,0,0,0,0,2,0,0,0], 
  [0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,1,1,1,1,1,0,1,0,0,0,0,0],
  [0,1,0,0,0,1,0,1,0,0,0,0,0],
  [0,1,0,0,0,1,0,1,0,0,0,0,0],
  [0,1,0,0,0,0,0,1,0,0,0,0,0],
  [0,1,1,1,1,1,0,1,0,0,0,0,0], 
  [0,1,0,0,0,0,0,1,0,0,0,0,0],
  [0,1,0,0,0,1,0,1,0,0,0,0,0],
  [0,1,1,1,1,1,1,1,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0,0],
  [2,0,0,0,0,0,0,0,0,0,0,0,2]
  ];
//Setup

//Logic
  //Movement
  
function moveObject (objToMove, axisToMoveOn, directionToMoveTo/* 1or-1*/) {
  if (objToMove.acting == false) {
    objToMove.acting = true
    let animationInterval;
    switch (axisToMoveOn) {
      case 0:
        objToMove.actXY[0] += directionToMoveTo
        if ((objToMove.actXY[0] <= movementBoundaries.maxXY[0] && objToMove.actXY[0] >= movementBoundaries.minXY[0]) && (checkColliders(objToMove.actXY))  ) {
          animationInterval = setInterval(() => {
            objToMove.styleXY[0] += directionToMoveTo * 5;
            objToMove.htmlStyleEquiv.style.left = objToMove.styleXY[0] + 'px'
            if (objToMove.styleXY[0] == (objToMove.actXY[0] * 25)) {
              clearInterval(animationInterval)
              objToMove.acting = false
            }
          }, 20)
        } else {
          objToMove.actXY[0] -= directionToMoveTo
          objToMove.acting = false
        }
        break;
      case 1:
        objToMove.actXY[1] += directionToMoveTo
        if ((objToMove.actXY[1] <= movementBoundaries.maxXY[1] && objToMove.actXY[1] >= movementBoundaries.minXY[1]) && (checkColliders(objToMove.actXY)) ) {
          animationInterval = setInterval(()=>{
          objToMove.styleXY[1] += directionToMoveTo * 5;
            objToMove.htmlStyleEquiv.style.top = objToMove.styleXY[1] + 'px'
            if (objToMove.styleXY[1] == (objToMove.actXY[1]*25)) {
              clearInterval(animationInterval)
              objToMove.acting = false
            }
          }, 20)
        } else {
          objToMove.actXY[1] -= directionToMoveTo
          objToMove.acting = false
        }
        break;
    }
  }
} 
  
function checkColliders (objActXY) {
  let playerMapCoords = map[objActXY[1]][objActXY[0]];
  switch (playerMapCoords) {
    case 0:
      return true;
      break;
    case 1:
      return false;
      break;
    case 2:
      actObject = [2,playerMapCoords];
      return true;
      break;
    
    default:
      return true;
      break;
  };
};
  
  
  
/*function control(direction) { 
  if (acting == false) {
    acting = true
    switch (direction) {
      case 1:
        player.actY -= 25;
        if (player.posY > 0 && checkColliders()) {
          interval = setInterval(animatePlayerUp, 20);
        } else {
          player.actY += 25;
          acting = false;
        };
        break;
      case 2:
        player.actX -= 25;
        if (player.posX > 0 && checkColliders()) {
          interval = setInterval(animatePlayerLeft,20);
        } else {
          player.actX += 25;
          acting = false;
        };
        break;
      case 3:
        player.actY += 25;
        if (player.posY < 375 && checkColliders()) {
          interval = setInterval(animatePlayerDown,20);
        } else {
          player.actY -= 25;
          acting = false;
        };
        break;
      case 4:
        player.actX += 25;
        if (player.posX < 300 && checkColliders()) {
          interval = setInterval(animatePlayerRight,20);
        } else {
          player.actX -= 25;
          acting = false;
        };
        break;
    };
  };
};*/


  //Movement
  
  //Actions
  function interactObject() {
    switch (actObject[0]) {
      case 2:
        map[player.actY/25][player.actX/25] = 1;
        new collider(player.actY/25,player.actX/25)
        break;
      default:
        break;
    }
  }
  //Actions
  
  //Miscellaneous 
function alertInfo() {
  alert("No Copyright infringement intended; Programmed and designed by Lejionnaire (OmegaCool)")
};
  //Miscellaneous 
//Logic

//Style
  //Animation
/*function animatePlayerDown() {
  if (player.posY < player.actY) {
    player.posY += 5;
    box.style.top = player.posY + 'px';
  } else {
    clearInterval(interval);
    acting = false;
    interactObject();
  };
};
function animatePlayerUp() {
  if (player.posY > player.actY) {
    player.posY -= 5;
    box.style.top = player.posY + 'px';
  } else {
    clearInterval(interval );
    acting = false;
    interactObject();
  };
};
function animatePlayerRight() {
  if (player.posX < player.actX ) {
    player.posX += 5;
    box.style.left = player.posX + 'px';
  } else {
    clearInterval(interval);
    acting = false;
    interactObject();
  };
};
function animatePlayerLeft() {
  if (player.posX > player.actX ) {
    player.posX -= 5;
    box.style.left = player.posX + 'px';
  } else {
    clearInterval(interval);
    acting = false;
    interactObject();
  };
};*/
  //Animations
  
  //Render
  function collider(mapY, mapX) {
    this.div = document.createElement('div')
    container.appendChild(this.div)
    let style = this.div.style
    //style.background = 'url("Images/images (55).jpeg")'
    style.backgroundColor = 'grey'
    style.width = '25px'
    style.height = '25px'
    style.top = (mapY * 25) + 'px'
    style.left = (mapX * 25) + 'px'
    style.position = 'absolute'
    style.border = '1px solid black'
  };
  
  
  
window.onload = () => {
  for (let i in map) {
    map[i].forEach((val, indx) => {
      switch (val) {
        case 1:
          new collider(i, indx)
          break;
        case 2:
          new function renderObject1() {
            this.div = document.createElement('div')
            container.appendChild(this.div)
            let style = this.div.style
            style.background = 'red'
            style.width = '25px'
            style.height = '25px'
            style.top = (i * 25) + 'px'
            style.left = (indx * 25) + 'px'
            style.position = 'absolute'
            style.border = '1px solid black'
          };
          break;  
      };
    }) 
  };
};
  //Render
//Style



  </script>
</body>
</html>